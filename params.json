{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Pseudo-Parallel, Passing-Procedure, Pretty-Promise. Asynchronous Collection & Procedure Control Flow","name":"pp.js","google":"UA-33864951-1","body":"# pp.js - pianissimo -\r\n\r\n[![Build Status](https://secure.travis-ci.org/VoQn/pp.js.png)](http://travis-ci.org/VoQn/pp.js)\r\n\r\n__pp.js__ calls __pianissimo.js__, meaning _Pseudo-Parallel_, _Passing-Procedure_, _Pretty-Promise_.\r\npp.js is javascript library for Asynchronous Collection &amp; Procedure Control Flow.\r\n\r\nthis library inspired by [async.js](https://github.com/caolan/async), [JsDeferred](http://cho45.stfuawsc.com/jsdeferred/), [$.Deferred](http://api.jquery.com/category/deferred-object/), [Promise/A](http://wiki.commonjs.org/wiki/Promises/A).\r\nAnd aiming provide compatible API.\r\n\r\nfor read this library specification see [Guide](#guide), [Reference](#reference)\r\n\r\n## License\r\nMIT License. see LICENSE file.\r\n\r\n## API\r\n\r\n### Continuation Object\r\nThese function create instance of `Promise` and `Generator` that controller\r\nabout Asynchonouse routine.\r\n\r\n+ [pp.promise](#promise) - Implement [Promise/A](http://wiki.commonjs.org/wiki/Promises/A) of [CommonJS](http://www.commonjs.org/)\r\n+ [pp.generator](#generator) - simple [Generator](http://wiki.ecmascript.org/doku.php?id=harmony:generators) like [ES-Harmony](https://mail.mozilla.org/pipermail/es-discuss/2008-August/006837.html)\r\n\r\n### Control Flow against Array as procedures\r\nThese API are very similar to functions of async.js.\r\nBut here is different argument rule, never blocking user thread, and faster.\r\n\r\n+ [pp.iterator](#iterator) - like [async.iterator](https://github.com/caolan/async#iterator)\r\n+ [pp.waterfall](#waterfall) - like [async.waterfall](https://github.com/caolan/async#waterfall)\r\n+ [pp.whilist](#whilist) - like\r\n  [async.whilist](https://github.com/caolan/async#whilist)\r\n+ [pp.until](#until) - like [async.until](https://github.com/caolan/async#until)\r\n+ [pp.fill](#fill) - like\r\n  [async.parallel](https://github.com/caolan/async#parallel)\r\n+ [pp.order](#order) - like [async.series](https://github.com/caolan/async#series)\r\n\r\n### Collection API\r\nThese API are very similar to functions of async.js.\r\nBut here is different argument rule, never blocking user thread, never occuring\r\n`Stack Over Flow`, faster (x 1.5 ~ 2.0), and use less heap memory (x ~0.5).\r\n\r\n+ [pp.each](#each) - like [async.forEach](https://github.com/caolan/async#forEach), [async.forEachLimit](https://github.com/caolan/async#forEach)\r\n+ [pp.eachOrder](#eachOrder) - like [async.forEachSeries](https://github.com/caolan/async#forEach)\r\n+ [pp.map](#map) - like [async.map](https://github.com/caolan/async#map)\r\n+ [pp.mapOrder](#mapOrder) - like [async.mapOrder](https://github.com/caolan/async#map)\r\n+ [pp.filter](#filter) - like\r\n  [async.filter](https://github.com/caolan/async#filter)\r\n+ [pp.reject](#reject) - like\r\n  [async.reject](https://github.com/caolan/async#reject)\r\n+ [pp.find](#find) - like [async.detect](https://github.com/caolan/async#detect)\r\n+ [pp.any](#any) - like [async.some](https://github.com/caolan/async#some)\r\n+ [pp.all](#all) - like [async.every](https://github.com/caolan/async#every)\r\n+ [pp.foldl](#foldl) - like [async.reduce](https://github.com/caolan/async#reduce)\r\n+ [pp.foldl1](#foldl1)\r\n+ [pp.foldr](#foldr) - like\r\n  [async.redureRight](https://github.com/caolan/async#reduce)\r\n+ [pp.foldr1](#foldr1)\r\n\r\n### Plugin Extention Interface, and Etc...\r\n\r\n+ [pp.extend](#extend) if want to add extention, call this.\r\n+ [pp.defer](#defer) deferring (use `process.nextTick` (node.js) or\r\n  `setTimeout(fn, 0, args...)`)\r\n+ [pp.TIME\\_SLICE](#timeslice) preset parameters X fps (ms)\r\n+ [pp.noConflict](#noconflict)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"guide\"/>\r\n# Guide\r\n## CPS (Continuation Passing Style)\r\n__pp.js__ is designed by CPS, _Continuation Passing Style_, for effective Asynchronous\r\nprocessing.\r\n\r\n## Trampolining, \"Pseudo-Parallel\"\r\n__pp.js__ doesn't provide _true_ parallel processing. Parallel processing is a strictly pseudo.\r\nThis pseudo-parallel processing on [Trampoling](http://en.wikipedia.org/wiki/Trampoline\\_\\(computing\\)).\r\n\r\n## Public API are curried\r\n__pp.js__ API are curried function.\r\n\r\nFor example, CPS sum of number array is this.\r\n\r\n```javascript\r\nvar printSum = pp.foldl(function(next, memo, value) {\r\n  if(typeof value !== 'number') {\r\n    next(new TypeError('\"folding\" require number, but ' + typeof value));\r\n  } else {\r\n    next(null, memo + value);\r\n  }\r\n}, function(error, result) {\r\n  console.log(result);\r\n}, 0); // See it! subject array has not apply!\r\n\r\nprintSum([10, 11, 12]); //=> 33\r\nprintSum([1, 2, 3, 4, 5]) //=> 15\r\n```\r\n\r\n## Invocation type of callback, \"fill\" and \"order\"\r\nIn designing Asynchronous operetion, maybe occur a problem that dependency with\r\neach procedures.\r\n\r\nBecause solve it, pp.js provide two iteration. _fill_ and _order_.\r\n\r\n### fill\r\n`fill` process is ASAP (As Soon As Possible)\r\n\r\n```javascript\r\nfireStack = [];\r\n\r\npp.fill([\r\n  function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('1st');\r\n      next(null, '1st');\r\n    }, 100);\r\n  }, function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('2nd');\r\n      next(null, '2nd');\r\n    }, 200);\r\n  }, function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('3rd');\r\n      next(null, '3rd');\r\n    }, 50)\r\n  }], function(error, result) {\r\n    // result     --- ['1st', '2nd', '3rd']\r\n    // fire_stack --- ['3rd', '1st', '2nd']\r\n  });\r\n```\r\n\r\n### order\r\n`order` process is keep invocation order.\r\n\r\n```javascript\r\nfireStack = [];\r\n\r\npp.order([\r\n  function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('1st');\r\n      next(null, '1st');\r\n    }, 100);\r\n  }, function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('2nd');\r\n      next(null, '2nd');\r\n    }, 200);\r\n  }, function(next) {\r\n    setTimeout(function() {\r\n      fireStack.push('3rd');\r\n      next(null, '3rd');\r\n    }, 50)\r\n  }], function(error, result) {\r\n    // result     --- ['1st', '2nd', '3rd']\r\n    // fire_stack --- ['1st', '2nd', '3rd']\r\n  });\r\n```\r\n\r\n## Type\r\nA difference between __pp.js__ with __async.js__ is consisting argument format.\r\n\r\n### TimeSlice: number\r\n\r\n`pp.TIME_SLICE` provide consts for frame rate.\r\n\r\n+ FPS\\_240 -  4ms\r\n+ FPS\\_120 -  8ms\r\n+ FPS\\_60  - 16ms\r\n+ FPS\\_30  - 33ms\r\n+ FPS\\_15  - 66ms\r\n+ FPS\\_1   -  1s (1000ms)\r\n\r\n### Iterator: function(callback, [somethings...])\r\n__pp.js__ defined __Iterator__ type that is `function(callback, [somethings...])` \r\n\r\nFor example, available iterator for Array\r\n\r\n+ `function(function:next, any:value, number:index, array:iterable)`\r\n+ `function(function:next, any:value, number:index)`\r\n+ `function(function:next, any:value)`\r\n+ `function(function:next)`\r\n\r\nfor Object,\r\n+ `function(function:next, any:value, string:key, object:iterable)`\r\n+ `function(function:next, any:value, string:key)`\r\n+ `function(function:next, any:value)`\r\n+ `function(function:next)`\r\n\r\niterator type need continuation function for 1st argument.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Predicator: function(callback, value, [key, iterable])\r\n__pp.js__ defined __Predicator__ type that is `function(callback, value, [key, iterable])`\r\n\r\nSpecially, predicator passing `boolean` result to callback.\r\n\r\n#### Example\r\n\r\n```javascript\r\nvar cpsIsEven = function(next, value) {\r\n  next(null, value % 2 === 0);\r\n};\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Accumulator: function(callback, memo, value, [key, iterable])\r\n__pp.js__ defined __Folding__ type that is `function(callback, memo, value, [key, iterable])`.\r\n\r\nfor accumulate array list.\r\n\r\n#### Example\r\n\r\n```javascript\r\nvar cpsAdd = function(next, memo, value) {\r\n  next(null, memo + value);\r\n};\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Callback: function(?Error, [somethings...])\r\n__pp.js__ defined __Callback__ type that is `function(Error, [somethings...])`.\r\n\r\nfirst argument, received Error, is accepted as __nullable__.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Iterable: (!Array | !Object as {string: any})\r\n__pp.js__ defined __Iterable__ type that is __not null__ Array or Object.\r\n\r\nprimitive values ... `undefined`, `null`, `string`, `boolean` and `number` aren't accepted.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"reference\"/>\r\n# Referrence\r\n\r\n__|||documentation writing now...|||__\r\n\r\n## Collection API\r\n<a name=\"each\"/>\r\n### pp.each(iterator, callback, iterable, [timeSlice])\r\n\r\n#### Arguments\r\n\r\n* iterator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.each(function(next, value, index, itrable) {\r\n    // do something\r\n    if (errorCondition) {\r\n      // when it should throw Error, instead of call\r\n      next(error);\r\n    } else if (haltCondition) {\r\n      // when it should halt iteration (purpose has been achieved)\r\n      next(null, result);\r\n    } else { // call iteration callback simply\r\n      next();\r\n    }\r\n  }, function(error) {\r\n    // do something when finish (or halt) iteration\r\n  }, ['a.coffee', 'b.coffee', 'c.coffee']);\r\n```\r\n\r\n<a name=\"eachOrder\"/>\r\n### pp.eachOrder(iterator, callback, iterable, [timeSlice])\r\n`pp.eachOrder` is another version of `pp.each` that keep invocation callback order.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"map\"/>\r\n### pp.map(iterator, callback, iterable, [timeSlice])\r\n\r\n#### Arguments\r\n\r\n* iterator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```javascript\r\nvar cpsSqMap = pp.map(function(next, value, index) {\r\n  if (typeof value !== 'number') {\r\n    next(new TypeError('cpsSqMap require number array. but include' +\r\n      typeof value + ' (' + value + ') at [' + index + ']'));\r\n  } else {\r\n    next(null, value * value);\r\n  });\r\n\r\ncpsSqMap(console.log, [1, 2, 3, 4, 5]);\r\n//=> null [1, 4, 9, 16, 25]\r\n\r\ncpsSqMap(console.log, [1, 2, '3', 4, 5]);\r\n//=> [TypeError: cpsSqMap require number array. but include string (3) at [2]] [ 1, 4 ]\r\n```\r\n\r\n<a name=\"mapOrder\"/>\r\n### pp.mapOrder(iterator, callback, iterable, [timeSlice])\r\n`pp.mapOrder` is another version of `pp.each` that keep invocation callback order.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"filter\"/>\r\n### pp.filter(predicator, callback, iterable, [timeSlice])\r\n`pp.filter`'s invocation is _order_\r\n\r\n#### Example\r\n\r\n```javascript\r\nvar cpsOdd = function(next, value) {\r\n  if (typeof value !== 'number') {\r\n    next(new TypeError('cpsOdd require number array. but include' +\r\n      typeof value + ' (' + value + ') at [' + index + ']'));\r\n  } else {\r\n    next(null, value % 2 === 1); // apply 2nd arg as boolean\r\n  }\r\n};\r\n\r\nvar printCallback = function(error, results) {\r\n  console.log(error ? error.message : results);\r\n};\r\n\r\npp.filter(cpsOdd, printCallback, [1, 2, 3, 4, 5]);\r\n//=> [1, 3, 5]\r\npp.filter(cpsOdd, printCallback, [2, 4, 6, 8, 10]);\r\n//=> []\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"reject\"/>\r\n### pp.reject(predicator, callback, iterable, [timeSlice])\r\ncomplement of `pp.filter`\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.reject(cpsOdd, printCallback, [1, 2, 3, 4, 5]);\r\n//=> [2, 4]\r\npp.reject(cpsOdd, printCallback, [10, 12, 14, 16, 18]);\r\n//=> [10, 12, 14, 16, 18]\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"find\"/>\r\n### pp.find(predicator, callback, iterable, [timeSlice])\r\nlookup match value from iterable.\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.find(cpsOdd, printCallback, [1, 2, 3, 4, 5]);\r\n//=> 1\r\npp.find(cpsOdd, printCallback, [10, 12, 14, 16, 18]);\r\n//=> undefined\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"any\"/>\r\n### pp.any(predicator, callback, iterable, [timeSlice])\r\n`pp.any` is CPS `Array.some`\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.any(cpsOdd, printCallback, [0, 2, 5, 8, 10])\r\n//=> true\r\npp.any(cpsOdd, printCallback, [2, 4, 6, 8, 10])\r\n//=> false\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"all\"/>\r\n### pp.all(predicator, callback, iterable, [timeSlice])\r\n`pp.all` is CPS `Array.every`\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.all(cpsOdd, printCallback, [1, 3, 6, 7, 9])\r\n//=> false\r\npp.all(cpsOdd, printCallback, [1, 3, 5, 7, 9])\r\n//=> true\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldl\"/>\r\n### pp.foldl(accumulator, callback, init, array, [timeSlice])\r\nfolding accumulation left(first of array) to right(last of array).\r\n\r\n#### Example\r\n```javascript\r\npp.foldl(function(next, r, x) {\r\n  next(null, r + x);\r\n}, function(error, result) {\r\n  console.log(result);  // => 15\r\n}, 0, [1, 2, 3, 4, 5]); // 0 + 1 + 2 + 3 + 4 + 5 => 15\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldl1\"/>\r\n### pp.foldl1(accumulator, callback, array, [timeSlice])\r\n`pp.foldl1` require Array has 1 or more length. use first element from Array as `init` value.\r\n\r\n```javascript\r\npp.foldl1(function(next, r, x) {\r\n  next(null, r + x);\r\n}, function(error, result) {\r\n  console.log(result); // => 15\r\n}, [1, 2, 3, 4, 5]);   // 1 + 2 + 3 + 4 + 5 => 15\r\n\r\npp.foldl1(function(next, r, x) {\r\n  next(null, r + x);\r\n}, function(error, result) {\r\n  console.log(error); // => TypeError\r\n}, []); // empty array :^(\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldr\"/>\r\n### pp.foldr(accumulator, callback, init, array, [timeSlice])\r\nfolding accumulation right(last of array) to left(first of array).\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.foldr(function(next, r, x) {\r\n  next(null, r + x);\r\n}, function(error, result) {\r\n  console.log(result);  // => 15\r\n}, 0, [1, 2, 3, 4, 5]); // 0 + 5 + 4 + 3 + 2 + 1 => 15\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldr1\"/>\r\n### pp.foldr1(accumulator, callback, array, [timeSlice])\r\n`pp.foldr1` require Array has 1 or more length. use last element from Array as `init` value.\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.foldr1(function(next, r, x) {\r\n  next(null, r + x);\r\n}, function(error, result) {\r\n  console.log(result); // => 15\r\n}, [1, 2, 3, 4, 5]);   // 5 + 4 + 3 + 2 + 1 => 15\r\n```\r\n\r\n"}