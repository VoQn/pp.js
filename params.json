{"body":"# pp.js - pianissimo -\r\n\r\n[![Build Status](https://secure.travis-ci.org/VoQn/pp.js.png)](http://travis-ci.org/VoQn/pp.js)\r\n\r\n__pp.js__ is called __pianissimo.js__, which means _Pseudo-Parallel_, _Passing-Procedure_, or _Pretty-Promise_.\r\npp.js is a javascript library for Asynchronous Collection &amp; Procedure Control Flow.\r\n\r\nthis library is inspired by [async.js](https://github.com/caolan/async), [JsDeferred](http://cho45.stfuawsc.com/jsdeferred/), [$.Deferred](http://api.jquery.com/category/deferred-object/), and [Promise/A](http://wiki.commonjs.org/wiki/Promises/A).\r\nAnd aiming provide compatible API.\r\n\r\nto read this library specification see [Guide](#guide), [Reference](#reference)\r\n\r\n## Faster, Fewer Cost, Parallel multi process\r\n\r\n![Benchmark pp.js vs async.js](https://lh4.googleusercontent.com/-N_dY3EUza5A/UE_932DxeBI/AAAAAAAAAlk/BoI8v5z7r00/s874/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88+2012-09-12+12.12.36.png)\r\n\r\n+ pp.js faster than async.js (more than 1.25x)\r\n+ pp.js use fewer memory async.js (lower than 1/3)\r\n+ pp.js work looks like parallel (see [Guide/Trampolining](#trampolining))\r\n+ while running pp.js process, It does not block user control as possible as.\r\n\r\n## License\r\nMIT License. see LICENSE file.\r\n\r\n## API\r\n\r\n### Continuation Object\r\nThese function create instance of `Promise` and `Generator` that controller\r\nabout Asynchonouse routine.\r\n\r\n+ [pp.promise](#promise) - Implement [Promise/A](http://wiki.commonjs.org/wiki/Promises/A) of [CommonJS](http://www.commonjs.org/)\r\n+ [pp.generator](#generator) - simple [Generator](http://wiki.ecmascript.org/doku.php?id=harmony:generators) like [ES-Harmony](https://mail.mozilla.org/pipermail/es-discuss/2008-August/006837.html)\r\n\r\n### Control Flow against Array as procedures\r\nThese API are very similar to functions of async.js.\r\nBut here is different argument rule, never blocking user thread, and faster.\r\n\r\n+ [pp.iterator](#iterator) - like [async.iterator](https://github.com/caolan/async#iterator)\r\n+ [pp.waterfall](#waterfall) - like [async.waterfall](https://github.com/caolan/async#waterfall)\r\n+ [pp.whilist](#whilist) - like\r\n  [async.whilist](https://github.com/caolan/async#whilist)\r\n+ [pp.until](#until) - like [async.until](https://github.com/caolan/async#until)\r\n+ [pp.fill](#fill) - like\r\n  [async.parallel](https://github.com/caolan/async#parallel)\r\n+ [pp.order](#order) - like [async.series](https://github.com/caolan/async#series)\r\n\r\n### Collection API\r\nThese API are very similar to functions of async.js.\r\nBut here is different argument rule, never blocking user thread, never occuring\r\n`Stack Over Flow`, faster (x 1.5 ~ 2.0), and use less heap memory (x ~0.5).\r\n\r\n+ [pp.each](#each) - like [async.forEach](https://github.com/caolan/async#forEach), [async.forEachLimit](https://github.com/caolan/async#forEach)\r\n+ [pp.map](#map) - like [async.map](https://github.com/caolan/async#map)\r\n+ [pp.filter](#filter) - like\r\n  [async.filter](https://github.com/caolan/async#filter)\r\n+ [pp.reject](#reject) - like\r\n  [async.reject](https://github.com/caolan/async#reject)\r\n+ [pp.find](#find) - like [async.detect](https://github.com/caolan/async#detect)\r\n+ [pp.any](#any) - like [async.some](https://github.com/caolan/async#some)\r\n+ [pp.all](#all) - like [async.every](https://github.com/caolan/async#every)\r\n+ [pp.foldl](#foldl) - like [async.reduce](https://github.com/caolan/async#reduce)\r\n+ [pp.foldr](#foldr) - like\r\n  [async.redureRight](https://github.com/caolan/async#reduce)\r\n\r\n### Plugin Extention Interface, and Etc...\r\n\r\n+ [pp.extend](#extend) if want to add extention, call this.\r\n+ [pp.defer](#defer) deferring (use `process.nextTick` (node.js) or\r\n  `setTimeout(fn, 0, args...)`)\r\n+ [pp.TIME\\_SLICE](#timeslice) preset parameters X fps (ms)\r\n+ [pp.noConflict](#noconflict)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"guide\"/>\r\n# Guide\r\n## CPS (Continuation Passing Style)\r\n__pp.js__ is designed by [CPS](http://en.wikipedia.org/wiki/Continuation-passing_style), _Continuation Passing Style_, for effective Asynchronous processing.\r\n\r\n```coffeescript\r\n# sync procedure\r\nsq = (x) ->\r\n  x * x\r\n\r\nconsole.log sq 10 # return 10 * 10 -> 100 -> console.log(100) => IO output\r\n\r\n# CPS procedure\r\ncpsSq = (next, x) ->\r\n  next x * x\r\n\r\ncpsSq console.log, 10 # console.log(10 * 10) -> console.log(100) => IO output\r\n\r\n# Async procedure\r\nheavyProcessing = (callback, parameters) ->\r\n  # do something (use long time, or network communication)\r\n  # ...\r\n  # ...\r\n  callback error, result # when process done, result apply asynchronouse\r\n\r\nheavyProcessing (e, r) -> # callback\r\n  if e # receive error\r\n    # do something\r\n  else # process has been succeeded\r\n    # do something\r\n, [### parameters ###]\r\n```\r\n\r\n<a name=\"trampolining\"/>\r\n## Trampolining, \"Pseudo-Parallel\"\r\n__pp.js__ doesn't provide _true_ parallel processing. Parallel processing is a strictly pseudo.\r\nThis pseudo-parallel processing on [Trampoling](http://en.wikipedia.org/wiki/Trampoline\\_\\(computing\\)).\r\n\r\n## Public API are curried\r\n__pp.js__ API are curried function.\r\n\r\nFor example, CPS sum of number array is this.\r\n\r\n```coffeescript\r\nprintSum = pp.foldl (next, memo, value) ->\r\n  if typeof value isnt 'number'\r\n    next new TypeError \"\\\"folding\\\" require number, but #{typeof value}\"\r\n  else\r\n    next null, memo + value\r\n  return\r\n, (error, result) ->\r\n  console.log result\r\n, 0 # See it! subject array has not apply!\r\n\r\nprintSum [10, 11, 12] #=> 33\r\nprintSum [1, 2, 3, 4, 5] #=> 15\r\n```\r\n\r\n## Invocation type of callback, \"fill\" and \"order\"\r\nIn designing Asynchronous operetion, maybe occur a problem that dependency with\r\neach procedures.\r\n\r\nBecause solve it, pp.js provide two iteration. _fill_ and _order_.\r\n\r\n### fill\r\n`fill` process is ASAP (As Soon As Possible)\r\n\r\n```coffeescript\r\nfireStack = []\r\n\r\npp.fill [\r\n  (next) ->\r\n    setTimeout ->\r\n      fireStack.push '1st'\r\n      next null, '1st'\r\n    , 100\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '2nd'\r\n      next null, '2nd'\r\n    , 200\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '3rd'\r\n      next null, '3rd'\r\n    , 50\r\n], (error, result) ->\r\n  # result     --- ['1st', '2nd', '3rd']\r\n  # fire_stack --- ['3rd', '1st', '2nd']\r\n```\r\n\r\n### order\r\n`order` process is keep invocation order.\r\n\r\n```coffeescript\r\nfireStack = []\r\n\r\npp.order [\r\n  (next) ->\r\n    setTimeout ->\r\n      fireStack.push '1st'\r\n      next null, '1st'\r\n    , 100\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '2nd'\r\n      next null, '2nd'\r\n    , 200\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '3rd'\r\n      next null, '3rd'\r\n    , 50\r\n], (error, result) ->\r\n  # result     --- ['1st', '2nd', '3rd']\r\n  # fire_stack --- ['1st', '2nd', '3rd']\r\n```\r\n\r\n### Difference?\r\n\r\n``` coffeescript\r\npp.fill F, G, H, CALLBACK\r\n# eval F -> eval G -> eval H -> (wait callback...) -> eval CALLBACK\r\n\r\npp.order F, G, H, CALLBACK\r\n# eval F -> (wait F callback...) -> eval G -> (wait G callback...) -> ...\r\n```\r\n\r\nWhy `pp.fill`'s name is _parallel_ but _fill_? Because it run all procedures and wait until all callback is filling.\r\n\r\n`pp.order` is keeping its ordering. When it began run procedure, wait that callback, run next procedure. Until last.\r\n\r\n## Type\r\nOne of difference between __pp.js__ with __async.js__ is consisted argument format.\r\n\r\n### TimeSlice: number (integer milli-second [0 &lt; t])\r\n\r\n`pp.TIME_SLICE` provide consts for frame rate.\r\n\r\n+ FPS\\_240 -  4ms\r\n+ FPS\\_120 -  8ms\r\n+ FPS\\_60  - 16ms\r\n+ FPS\\_30  - 33ms\r\n+ FPS\\_15  - 66ms\r\n+ FPS\\_1   -  1s (1000ms)\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Callback: function(?Error, [somethings...])\r\n__pp.js__ defined __Callback__ type that is `function(Error, [somethings...])`.\r\n\r\nfirst argument, received Error, is accepted as __nullable__.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Iterable: (!Array | !Object as {string: any})\r\n__pp.js__ defined __Iterable__ type that is __not null__ Array or Object.\r\n\r\nprimitive values ... `undefined`, `null`, `string`, `boolean` and `number` aren't accepted.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Iterator: function(callback, [somethings...])\r\n__pp.js__ defined __Iterator__ type that is `function(callback, [somethings...])` \r\n\r\nFor example, available iterator for Array\r\n\r\n+ `function(function:next, any:value, number:index, array:iterable)`\r\n+ `function(function:next, any:value, number:index)`\r\n+ `function(function:next, any:value)`\r\n+ `function(function:next)`\r\n\r\nfor Object,\r\n+ `function(function:next, any:value, string:key, object:iterable)`\r\n+ `function(function:next, any:value, string:key)`\r\n+ `function(function:next, any:value)`\r\n+ `function(function:next)`\r\n\r\niterator type need continuation function for 1st argument.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Predicator: function(callback, value, [key, iterable])\r\n__pp.js__ defined __Predicator__ type that is `function(callback, value, [key, iterable])`\r\n\r\nSpecially, predicator passing `boolean` result to callback.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\ncpsIsEven = (next, value) ->\r\n  next null, value % 2 is 0\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n### Accumulator: function(callback, memo, value, [key, iterable])\r\n__pp.js__ defined __Folding__ type that is `function(callback, memo, value, [key, iterable])`.\r\n\r\nfor accumulate array list.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\ncpsAdd = (next, memo, value) ->\r\n  next null, memo + value\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"reference\"/>\r\n# Referrence\r\n\r\n__|||documentation writing now...|||__\r\n\r\n## Control Flow\r\n<a name=\"iterator\"/>\r\n### pp.iterator(procs)\r\n\r\n#### Arguments\r\n* procs {Array.&lt;function(any...)&gt;} - procedure list\r\n\r\n#### Example\r\n\r\n```coffeescript\r\ncurrent = ''\r\niter = pp.iterator [\r\n  ->\r\n    current = '1st'\r\n  , ->\r\n    current = '2nd'\r\n  , ->\r\n    current = '3rd'\r\n]\r\n\r\niter2 = iter()\r\nconsole.log current # '1st'\r\n\r\niter3 = iter2()\r\nconsole.log current # '2nd'\r\n\r\niter3()\r\nconsole.log current # '3rd'\r\n\r\niter4 = iter.next()\r\niter4()\r\nconsole.log current # '2nd'\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"waterfall\"/>\r\n### pp.waterfall(procs, callback, [timeSlice])\r\n\r\n#### Arguments\r\n* procs {Array.&lt;Iterator&gt;} - procedure list\r\n* callback(error, results...) - callback after iteration\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n```coffeescript\r\npp.waterfall [\r\n  (next) ->\r\n    next null, 1\r\n  , (next, v) ->\r\n    next null, v, v * 2 # {v: 1}\r\n  , (next, v1, v2) ->\r\n    next null, v1 + v2 # {v1: 1, v2: 2}\r\n], (error, result) ->\r\n  console.log error is null # true\r\n  console.log result # 3\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"whilist\"/>\r\n### pp.whilist(predicator, iterator, callback, init, [timeSlice])\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"until\"/>\r\n### pp.until(predicator, iterator, callback, init, [timeSlice])\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"fill\"/>\r\n### pp.fill(procs, callback, [timeSlice])\r\n\r\n#### Arguments\r\n* procs: Array.&lt;Iterator&gt; task procedure list\r\n* callback(?Error, Array) callback procedure\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n```coffeescript\r\nfireStack = []\r\n\r\npp.fill [\r\n  (next) ->\r\n    setTimeout ->\r\n      fireStack.push '1st'\r\n      next null, '1st'\r\n    , 100\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '2nd'\r\n      next null, '2nd'\r\n    , 200\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '3rd'\r\n      next null, '3rd'\r\n    , 50\r\n], (error, result) ->\r\n  # result     --- ['1st', '2nd', '3rd']\r\n  # fire_stack --- ['3rd', '1st', '2nd']\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"order\"/>\r\n### pp.order(procs, callback, [timeSlice])\r\n\r\n#### Arguments\r\n* procs: Array.&lt;Iterator&gt; task procedure list\r\n* callback(?Error, Array) callback procedure\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n```coffeescript\r\nfireStack = []\r\n\r\npp.order [\r\n  (next) ->\r\n    setTimeout ->\r\n      fireStack.push '1st'\r\n      next null, '1st'\r\n    , 100\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '2nd'\r\n      next null, '2nd'\r\n    , 200\r\n  , (next) ->\r\n    setTimeout ->\r\n      fireStack.push '3rd'\r\n      next null, '3rd'\r\n    , 50\r\n], (error, result) ->\r\n  # result     --- ['1st', '2nd', '3rd']\r\n  # fire_stack --- ['1st', '2nd', '3rd']\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n## Collection API\r\n<a name=\"each\"/>\r\n### pp.each(iterator, callback, iterable, [timeSlice])\r\n\r\n#### Arguments\r\n\r\n* iterator(callback, [value, key, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.each (next, value, index, itrable) ->\r\n  # do something\r\n  if errorCondition\r\n    # when it should throw Error, instead of call\r\n    next new Error \"error\"\r\n  else if haltCondition\r\n    # when it should halt iteration (purpose has been achieved)\r\n    next(null, result);\r\n  else # call iteration callback simply\r\n    next()\r\n, (error) ->\r\n  # do something when finish (or halt) iteration\r\n, ['a.coffee', 'b.coffee', 'c.coffee']\r\n```\r\n\r\n<a name=\"eachOrder\"/>\r\n### pp.eachOrder(iterator, callback, iterable, [timeSlice])\r\n`pp.eachOrder` is another version of `pp.each` that keep invocation callback order.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"map\"/>\r\n### pp.map(iterator, callback, iterable, [timeSlice])\r\n\r\n#### Arguments\r\n\r\n* iterator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\ncpsSqMap = pp.map (next, value, index) ->\r\n  if  typeof value isnt 'number'\r\n    next new TypeError \"cpsSqMap require number array.\r\n     but include #{typeof value} (#{value}) at [#{index}]\"\r\n  else\r\n    next null, value * value\r\n\r\ncpsSqMap console.log, [1, 2, 3, 4, 5] #=> null [1, 4, 9, 16, 25]\r\n\r\ncpsSqMap console.log, [1, 2, '3', 4, 5]\r\n#=> [TypeError: cpsSqMap require number array. but include string (3) at [2]] [ 1, 4 ]\r\n```\r\n\r\n<a name=\"mapOrder\"/>\r\n### pp.mapOrder(iterator, callback, iterable, [timeSlice])\r\n`pp.mapOrder` is another version of `pp.each` that keep invocation callback order.\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"filter\"/>\r\n### pp.filter(predicator, callback, iterable, [timeSlice])\r\n`pp.filter`'s invocation is _order_\r\n\r\n#### Arguments\r\n\r\n* predicator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\ncpsOdd = (next, value) ->\r\n  if typeof value isnt 'number'\r\n    next new TypeError \"cpsOdd require number array. but include\r\n     #{typeof value} (#{value}) at [#{index}]\"\r\n  else\r\n    next null, value % 2 is 1 # apply 2nd arg as boolean\r\n\r\nprintCallback = (error, results) ->\r\n  console.log if error then error.message else results\r\n\r\npp.filter cpsOdd, printCallback, [1, 2, 3, 4, 5]\r\n#=> [1, 3, 5]\r\n\r\npp.filter cpsOdd, printCallback, [2, 4, 6, 8, 10]\r\n#=> []\r\n\r\ncpsPrivate = (next, value, key) ->\r\n  next null, key.match /^_/\r\n\r\n# filtering to hashmap\r\npp.filter cpsPrivate, printCallback,\r\n  name: 'John'\r\n  age: 26\r\n  gender: MALE\r\n  _hasGirlFriend: yes\r\n#=> \"{_hasGirlFriend: true}\" (o_O)\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"reject\"/>\r\n### pp.reject(predicator, callback, iterable, [timeSlice])\r\ncomplement of `pp.filter`\r\n\r\n#### Arguments\r\n\r\n* predicator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.reject cpsOdd, printCallback, [1, 2, 3, 4, 5]\r\n#=> [2, 4]\r\n\r\npp.reject cpsOdd, printCallback, [10, 12, 14, 16, 18]\r\n#=> [10, 12, 14, 16, 18]\r\n\r\n# filtering to hashmap\r\npp.reject cpsPrivate, printCallback,\r\n  name: 'John'\r\n  age: 26\r\n  gender: MALE\r\n  _hasGirlFriend: yes\r\n#=> \"{name: 'John', age: 26, gender: \"male\"}\" (-_-)\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"find\"/>\r\n### pp.find(predicator, callback, iterable, [timeSlice])\r\nlookup match value from iterable.\r\n\r\n#### Arguments\r\n\r\n* predicator(callback, [value, key, iterable]) - iteration procedure\r\n* callback(error, [value, key]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.find cpsOdd, printCallback, [1, 2, 3, 4, 5]\r\n#=> 1\r\n\r\npp.find cpsOdd, printCallback, [10, 12, 14, 16, 18]\r\n#=> undefined\r\n\r\npp.find (next, value, key) ->\r\n  next null, key.match /^#[a-zA-Z0-9]/\r\n, (error, value, key) ->\r\n  console.log \"value: #{value}, key: #{key}\"\r\n, # js Object as CSS\r\n  body:\r\n    width: '100%'\r\n  '#container':\r\n    'background-color': '#eee'\r\n  '.notice':\r\n    color: '#000'\r\n#=>value: {'background-color': '#eee'} key: '#container'\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"any\"/>\r\n### pp.any(predicator, callback, iterable, [timeSlice])\r\n`pp.any` is CPS `Array.some`\r\n\r\n#### Arguments\r\n\r\n* predicator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, bool, [key]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.any cpsOdd, printCallback, [0, 2, 5, 8, 10]\r\n#=> true\r\npp.any cpsOdd, printCallback, [2, 4, 6, 8, 10]\r\n#=> false\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"all\"/>\r\n### pp.all(predicator, callback, iterable, [timeSlice])\r\n`pp.all` is CPS `Array.every`\r\n\r\n#### Arguments\r\n\r\n* predicator(callback, [value, index, iterable]) - iteration procedure\r\n* callback(error, bool, [key]) - callback for after iteration\r\n* iterable - **not Nullable** Array or Object as HashMap (`{{string: *}}`)\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.all cpsOdd, printCallback, [1, 3, 6, 7, 9]\r\n#=> false\r\npp.all cpsOdd, printCallback, [1, 3, 5, 7, 9]\r\n#=> true\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldl\"/>\r\n### pp.foldl(accumulator, callback, init, array, [timeSlice])\r\nfolding accumulation left(first of array) to right(last of array).\r\n\r\n`pp.foldl`'s invocation is _order_\r\n\r\n#### Arguments\r\n\r\n* accumulator(callback, memo, value, [index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* init - init value for accumulation\r\n* array - **not Nullable** Array\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n```coffeescript\r\npp.foldl (next, r, x) ->\r\n  next null, r + x\r\n, (error, result) ->\r\n  console.log result # => 15\r\n, 0, [1, 2, 3, 4, 5] # 0 + 1 + 2 + 3 + 4 + 5 => 15\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldl1\"/>\r\n### pp.foldl1(accumulator, callback, array, [timeSlice])\r\n`pp.foldl1` require Array has 1 or more length. use first element from Array as `init` value.\r\n\r\n#### Arguments\r\n\r\n* accumulator(callback, memo, value, [index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* array - **not Nullable** Array\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.foldl1 (next, r, x) ->\r\n  next null, r + x\r\n, (error, result) ->\r\n  console.log result # => 15\r\n, [1, 2, 3, 4, 5] # 1 + 2 + 3 + 4 + 5 => 15\r\n\r\npp.foldl1 (next, r, x) ->\r\n  next null, r + x\r\n, (error, result) ->\r\n  console.log error # => TypeError\r\n, [] # empty array :^(\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldr\"/>\r\n### pp.foldr(accumulator, callback, init, array, [timeSlice])\r\nfolding accumulation right(last of array) to left(first of array).\r\n\r\n`pp.foldl`'s invocation is _order_\r\n\r\n#### Arguments\r\n\r\n* accumulator(callback, memo, value, [index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* init - init value for accumulation\r\n* array - **not Nullable** Array\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```coffeescript\r\npp.foldr (next, r, x) ->\r\n  next null, r + x\r\n, (error, result) ->\r\n  console.log result # => 15\r\n, 0, [1, 2, 3, 4, 5] # 0 + 5 + 4 + 3 + 2 + 1 => 15\r\n```\r\n\r\n-------------------------------------------------------------------------------\r\n\r\n<a name=\"foldr1\"/>\r\n### pp.foldr1(accumulator, callback, array, [timeSlice])\r\n`pp.foldr1` require Array has 1 or more length. use last element from Array as `init` value.\r\n\r\n#### Arguments\r\n\r\n* accumulator(callback, memo, value, [index, iterable]) - iteration procedure\r\n* callback(error, [somethings...]) - callback for after iteration\r\n* array - **not Nullable** Array\r\n* timeSlice - **optional** time slice for iteration loop.\r\n\r\n#### Example\r\n\r\n```javascript\r\npp.foldr1 (next, r, x) ->\r\n  next null, r + x\r\n, (error, result) ->\r\n  console.log result # => 15\r\n, [1, 2, 3, 4, 5]   # 5 + 4 + 3 + 2 + 1 => 15\r\n```\r\n\r\n","tagline":"Pseudo-Parallel, Passing-Procedure, Pretty-Promise. Asynchronous Collection & Procedure Control Flow","google":"UA-33864951-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"pp.js"}